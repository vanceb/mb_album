{% extends "base.html" %}

{% block title %}Barcode Scanner{% endblock %}

{% block header %}Barcode Scanner{% endblock %}

{% block content %}
<h2>Barcode Scanner</h2>
<p>Enter barcodes below. Each barcode will be automatically looked up and added to the catalog.</p>

<div id="scanner-area">
    <input type="text" id="barcode-input" placeholder="Scan or type barcode here" autofocus>
    <button onclick="processBarcode()"><i class="fas fa-search"></i> Lookup</button>
</div>

<div id="status" style="margin-top: 1rem;"></div>

<div id="recent-scans" style="margin-top: 2rem;">
    <h3>Recent Scans</h3>
    <div id="scan-results"></div>
</div>
{% endblock %}

{% block scripts %}
<script>
let isProcessing = false;

document.getElementById('barcode-input').addEventListener('keydown', function(event) {
    if (event.key === 'Enter' && !isProcessing) {
        processBarcode();
    }
});

async function processBarcode() {
    const input = document.getElementById('barcode-input');
    const barcode = input.value.trim();
    
    if (!barcode) {
        showStatus('Please enter a barcode', 'warning');
        return;
    }
    
    if (isProcessing) {
        showStatus('Please wait for current scan to complete', 'warning');
        return;
    }
    
    isProcessing = true;
    showStatus('Processing barcode...', 'info');
    
    try {
        // Add timeout to prevent infinite hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, 30000); // 30 second timeout
        
        const response = await fetch('/admin/scan', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ barcode: barcode }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        const data = await response.json();
        
        if (response.ok && data.success) {
            if (data.status === 'already_exists') {
                showStatus(`Already in catalog: ${data.title} by ${data.artist}`, 'success');
                addToRecentScans({...data, status: 'Already in catalog'});
            } else if (data.status === 'queued') {
                showStatus(`Barcode queued for processing (position ${data.position})`, 'info');
                addToRecentScans({
                    barcode: data.barcode,
                    title: 'Processing...',
                    artist: 'Please wait',
                    status: `Queued (position ${data.position})`
                });
                // Start polling for status updates
                pollBarcodeStatus(data.barcode);
            } else if (data.status === 'in_queue') {
                showStatus(`Barcode already in queue: ${data.queue_status}`, 'warning');
            }
            input.value = '';  // Clear input for next scan
        } else {
            showStatus(data.error || 'Unknown error occurred', 'error');
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            showStatus('Request timeout - but barcode may still be processing. Check Recent Scans below.', 'warning');
        } else {
            showStatus('Network error: ' + error.message, 'error');
        }
    } finally {
        isProcessing = false;
        input.focus();  // Return focus to input
    }
}

async function pollBarcodeStatus(barcode) {
    const maxAttempts = 120; // Poll for up to 2 minutes
    let attempts = 0;
    
    const poll = async () => {
        try {
            const response = await fetch(`/admin/status/${barcode}`);
            const data = await response.json();
            
            if (response.ok) {
                updateBarcodeStatus(barcode, data);
                
                if (data.status === 'complete') {
                    showStatus(`Completed: ${data.title} by ${data.artist}`, 'success');
                    return; // Stop polling
                } else if (data.status === 'failed') {
                    showStatus(`Failed to process ${barcode}: ${data.error || 'Unknown error'}`, 'error');
                    return; // Stop polling
                }
            }
            
            attempts++;
            if (attempts < maxAttempts) {
                setTimeout(poll, 2000); // Poll every 2 seconds
            } else {
                showStatus(`Polling timeout for ${barcode}`, 'warning');
            }
        } catch (error) {
            attempts++;
            if (attempts < maxAttempts) {
                setTimeout(poll, 5000); // Longer delay on error
            }
        }
    };
    
    // Start polling after initial delay
    setTimeout(poll, 2000);
}

function updateBarcodeStatus(barcode, statusData) {
    // Find and update the barcode in recent scans
    const resultsDiv = document.getElementById('scan-results');
    const scanItems = resultsDiv.querySelectorAll('div');
    
    for (const item of scanItems) {
        const itemBarcode = item.querySelector('small')?.textContent?.split('Barcode: ')[1]?.split(' |')[0];
        if (itemBarcode === barcode) {
            let statusText = statusData.status;
            let title = statusData.title || 'Processing...';
            let artist = statusData.artist || 'Please wait';
            
            if (statusData.status === 'processing' && statusData.steps) {
                const completedSteps = Object.values(statusData.steps).filter(Boolean).length;
                statusText = `Processing (${completedSteps}/3 steps)`;
            } else if (statusData.status === 'pending' && statusData.position) {
                statusText = `Queued (position ${statusData.position})`;
            }
            
            item.innerHTML = `
                <strong>${title}</strong> by ${artist}<br>
                <small>Barcode: ${barcode} | Status: ${statusText}</small>
            `;
            
            // Update styling based on status
            if (statusData.status === 'complete') {
                item.style.backgroundColor = '#d4edda';
                item.style.borderColor = '#c3e6cb';
            } else if (statusData.status === 'failed') {
                item.style.backgroundColor = '#f8d7da';
                item.style.borderColor = '#f5c6cb';
            } else {
                item.style.backgroundColor = '#fff3cd';
                item.style.borderColor = '#ffeaa7';
            }
            break;
        }
    }
}

function showStatus(message, type) {
    const statusDiv = document.getElementById('status');
    statusDiv.innerHTML = `<div class="alert alert-${type === 'info' ? 'warning' : type}">${message}</div>`;
    
    // Auto-clear success messages after 3 seconds
    if (type === 'success') {
        setTimeout(() => {
            statusDiv.innerHTML = '';
        }, 3000);
    }
}

function addToRecentScans(data) {
    const resultsDiv = document.getElementById('scan-results');
    const scanItem = document.createElement('div');
    scanItem.style.padding = '1rem';
    scanItem.style.border = '1px solid #ddd';
    scanItem.style.borderRadius = '4px';
    scanItem.style.marginBottom = '0.5rem';
    
    // Set background color based on status
    if (data.status === 'Already in catalog' || data.status === 'complete') {
        scanItem.style.backgroundColor = '#d4edda';
        scanItem.style.borderColor = '#c3e6cb';
    } else if (data.status && data.status.includes('failed')) {
        scanItem.style.backgroundColor = '#f8d7da';
        scanItem.style.borderColor = '#f5c6cb';
    } else {
        scanItem.style.backgroundColor = '#fff3cd';
        scanItem.style.borderColor = '#ffeaa7';
    }
    
    const title = data.title || 'Processing...';
    const artist = data.artist || 'Please wait';
    const statusText = data.status || 'Unknown';
    const firstRelease = data.first_release || data.release_date || '';
    
    scanItem.innerHTML = `
        <strong>${title}</strong> by ${artist}<br>
        <small>Barcode: ${data.barcode} | Status: ${statusText}${firstRelease ? ' | ' + firstRelease : ''}</small>
    `;
    
    // Insert at the top
    if (resultsDiv.firstChild) {
        resultsDiv.insertBefore(scanItem, resultsDiv.firstChild);
    } else {
        resultsDiv.appendChild(scanItem);
    }
    
    // Keep only the last 10 scans
    while (resultsDiv.children.length > 10) {
        resultsDiv.removeChild(resultsDiv.lastChild);
    }
}

// Auto-focus on input when page loads
window.onload = function() {
    document.getElementById('barcode-input').focus();
};
</script>
{% endblock %}